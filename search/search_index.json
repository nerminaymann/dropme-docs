{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dropme API","text":""},{"location":"#content","title":"Content","text":"<ul> <li>Getting Started</li> <li>Users_api</li> <li>Competition_api</li> <li>Machine_api</li> <li>Community_api</li> <li>Deployment</li> </ul>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#introduction","title":"Introduction","text":"<p>For deploying our API we use railway which is a platform as a service that allows us to deploy our code from GitHub directly, any changes made to the main branch will start a new deployment process on railway.</p>"},{"location":"deployment/#dockerfile","title":"Dockerfile","text":"<p>Railway deploys our code by runnig it inside a docker container.  </p> <p>We use a <code>Dockerfile</code> to customize the container. We customize the container, because standard railway containers don't have the dependencies we need like <code>GDAL</code> for geodjango.  </p> <p>Note: In deployment we store our environment variables using railway variables, these variables get injected into our container during build time, to use them, they must be specified at the start of the Dockerfile after <code>From ubuntu:latest</code> with:</p> <pre><code>ARG EnvironmentVariable\n</code></pre> <p>Then set as env variable with:</p> <pre><code>ENV EnvironmentVariable=${EnvironmentVariable}\n</code></pre>"},{"location":"deployment/#superviseconf","title":"Supervise.conf","text":"<p>This is our Supervisor config file. We mainly use supervisor to allow us to run multiple processes of our ASGI server Daphne on same port.  </p> <p>Any supervisor conf files should be placed in <code>/etc/supervisor/conf.d/</code> which we do in the <code>Dockerfile</code> <pre><code>COPY supervise.conf /etc/supervisor/conf.d/\n</code></pre></p> <p>Note: Supervisor runs <code>Daphne</code> as a background service which for some reason can't read our env variables that is why we read them from a <code>.env</code> file which was created in the Dockerfile. <pre><code>RUN touch .env\nRUN printenv  &gt; .env\n</code></pre></p>"},{"location":"deployment/#nginxconf","title":"Nginx.conf","text":"<p>This is our Nginx config file. It is the recommended setup to use <code>Nginx</code> when using <code>Daphne</code> for better security and performance.  </p> <p>Nginx conf should be placed in <code>/etc/nginx/nginx.conf</code> which we do in the <code>Dockerfile</code> <pre><code>COPY nginx.conf /etc/nginx/nginx.conf\n</code></pre></p> <p>IMPORTANT NOTE: If you look at nginx.conf you will find that nginx listens on port 80, the port number must be stored in railway variables for railway to know which port does our server listen on, the deployment won't work without this.</p>"},{"location":"deployment/#startsh","title":"start.sh","text":"<p>This is the script that runs when our Docker container starts. It runs database migrations, start supervisor and nginx and prints daphne and nginx log to stdout.</p>"},{"location":"deployment/#media-storage","title":"Media Storage","text":"<p>As mentioned before, any changes made to the main branch will start a new deployment process, which means the container state is not persistent and that is why we need a third party app for media storage.  </p> <p>Media files include: </p> <ul> <li>User profile photos </li> <li>Files uploaded on the community channels</li> </ul> <p>Right now we are using Blackblaze for media storage.</p>"}]}